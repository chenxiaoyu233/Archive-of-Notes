#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup
* 概述
** 计算机分类
*** Flynn’s 分类
    - S: Single, M: multi
    - I: Instruction, D: Data
    - SISD
      - 应用: 早期的多数微处理器
    - MISD
      - 应用: 处理器阵列, 向量流水线, 标准指令集的多媒体扩展, GPU
    - SIMD
      - 应用: 多滤波器对单信号流进行操作, 多重加密算法对单个编码信息进程操作
    - MIMD
      - 应用: 多核芯片, 服务器, PCs
*** 市场分类
    - 个人移动设备
      - 成本, 功耗, 尺寸, 实际性能, 存储器容量, 存储器优化, 代码优化
    - 桌面计算机
      - 性价比, 计算和图形性能, 价格
      - 包括个人计算机和工作站
    - 服务器
      - 多处理器结构
      - 可靠性
      - 可扩展性
      - 吞吐量
      - 按规模分类
        - /中型/小型/入门
      - 按外形与结构来分
        - 塔式/机柜式
      - 按是否通用开放分类
        - 通用开放系统/非通用开放系统
    - 集群/仓库级计算机
      - 集群计算机: 一组桌面级或服务器通过局域网链接, 运行时想一个大型计算机系统
      - 仓库级计算机: 最大规模的集群
        - 特殊问题: 配电, 制冷
      - 多处理器结构
      - 性价比, 吞吐量, 可靠性
    - 嵌入式计算机
      - 计算机作为应用产品的核心控制部件, 隐藏在各种装置, 设备和系统之中, 就是嵌入式
      - 有严格的资源限制
      - 处理器核心和 _特定的应用电路_ 在一起使用
      - 嵌入式 VS 非嵌入式: 是否能运行第三方软
*** 计算机系统结构的定义和计算机的设计任务
**** 计算机系统结构的原始概念
     由程序员看见的[计算]系统的属性, 即概念性结构和功能性行为.
     (区分数据流动, 控制逻辑设计的组成和物理实现)
**** 计算机系统结构的现代定义
     满足功能, 性能和价格目标的前提下, 设计,选择和互联硬件部件构成计算机.
*** 实现技术的趋势
*** 集成电路的功耗趋势
*** 成本的趋势
*** 可靠性
    - MTTF: mean time to failure
    - MTTR: mean time to repair
    - FIT(故障率): 1/MTTF
    - MTBF: mean time betwen failure, MTTF + MTTR
    - 可用性: MTTF / (MTTF + MTTR)
*** 测量, 报告和总结计算机性能
**** 性能指标
    - 墙钟时间(响应时间), 程序开始执行到结束执行看到的时间, 各方都认可的测量指标
    - CPU时间, CPU真正用于计算的时间, 分为用户CPU时间和系统CPU时间.
    - 吞吐量, 每秒钟处理的事务数量
    - MIPS: Millions of Instruction per Second
    - 基准测试程序(SPEC)
**** 加权执行时间
     - $\sum_{i=1}^n \mbox{Weight}_i \times \mbox{Time}_i$
**** 加权速率
     - $\frac{1}{\sum_{i=1}^n \frac{\mbox{Weight}_i}{\mbox{Rate}}}$
**** SPEC性能评价
     - SPEC Ratio
       \[
       \mbox{SPECRatio}_A = \frac{\mbox{参考计算机的执行时间}}{\mbox{A的执行时间}}
       \]
     - SPEC Mark
       \[
       SM = \sqrt[n]{\prod_{i=1}^n \mbox{SPECRatio}_i}
       \]
*** 计算机设计的量化原则
**** 并行性
**** 局部性
**** 注重常用事件
**** Amdahl定律
     - 加速比:
       $S_n = \frac{T_0}{T_n}$, 其中, $T_0$ 是改前的事件, $T_n$ 是改进后的时间.
     - $T_n = T_0(1 - F_e + \frac{F_e}{S_e})$
**** CPU性能公式
     - CPU time = instruction count $\times$ CP
* 指令系统原理与实例
** 指令集系统结构(ISA)分类
   - 堆栈系统结构
   - 累加器系统结构
   - 通用寄存器系统结构
** 存储器寻址
*** 大端/小端
*** 对齐
    假设一个s字节数据的地址是A,如果A mod s=0, 访问该地址就是对齐的。
*** 寻址方式
    指令中如何指定所要访问操作数的地址
    - 位移量寻址方式 (13 ~ 16位)
    - 立即数寻址方式 (8 ~ 16位)
    - 寄存器间址
** 操作数的大小和类型
** 指令系统的操作
   - 算数和逻辑运算
   - 数据传输
   - 控制
** 控制流指令
*** 分类
    - 条件转移
    - 跳转
    - 过程调用
    - 过程返回
*** 控制流指令的寻址方式
    - PC相对寻址
    - 寄存器间接跳转
*** 条件转移可选方案
    [[file:pic/%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E5%8F%AF%E9%80%89%E6%96%B9%E6%A1%88.png]]
*** 过程调用的可选方案
    - 调用者保存
    - 被调用者保存
** 指令系统的编码
*** 常见的编码方式
    - 变长, 关注代码量
    - 定长, 关注执行性能
    - 混合, 折中
** 编译器的角色
*** 主要目标
    - 正确性
    - 编译后的代码的执行速度
*** 与编译相关的主要系统结构特征
    - 并行性
    - 存储层次结构
** MIPS系统结构
* 流水线技术
** 定义
     - 流水线是利用执行指令操作之间的并行性， 实现多条指令重叠执行的技术
     - 机器周期(流水线周期):指令沿流水线移动一个 流水段的时间。长度取决于最慢的流水段，一般是一个
       时钟周期(有时是两个时钟周期)。
     - 吞吐量:单位时间从流水线流出的指令数。
** 流水线的主要障碍 -- 流水线冒险 (相关)
*** 冒险分类
    - 结构冒险: 指令重叠执行时, 发生硬件资源冲突
    - 数据冒险: 几条指令重叠执行时, 后面指令依赖前面指令的结果却没有准备好(还没有计算或存储)
    - 控制冒险(流水线执行转移指令时): 在进入ID段时, 
      转移条件和转移目标地址不能按时提供给IF段取指令
**** 冒险出现时
     - 避免流水线上有冒险的指令执行下一流水段 (冒险总是可以通过停顿解决)
     - 一个流水线停顿也被称为流水线气泡
*** 有停顿的流水线的性能
    - 假设理想流水线的CPI为1, 则有停顿的流水线的CPI为: 1 + 平均每条指令的停顿周期数.
    - 近似认为流水线的时钟周期和非流水线的时钟周期相等.
    - 流水线加速比 = 非流水线CPI / (1 + 平均每条指令停顿的周期数)
                 = 流水线级数 / (1 + 平均每条指令停顿的周期数)
** 结构冒险
*** 寄存器堆的多重访问
    WB先写, ID后读
*** 存储器(RAM)的多重访问
    - 插入stall
    - 分开指令存储器和数据存储器
    - 给RAM加个端口
    - 使用指令缓冲器
*** 没有完全流水线化的功能部件
    - 比如非常耗时的浮点数运算部件(一次运算占好几个周期)
*** 有时允许结构冒险
    - 减少成本(如果结构冒险不经常发生, 则消除的代价太大)
    - 减少部件延迟
*** 主要解决方法
    - 增加硬件资源
    - 功能部件完全流水
** 数据冒险
*** 流水线停顿
    - 软件方法
    - 硬件方法
*** Forwarding + Load stall
**** Load stall 的影响
     - 因为load的后面通常马上就要用load读进来的数据, 所以对性能非常影响 
**** 可能的解决方法:
     编译器重排, 避免load stall
** 控制冒险
*** 原因
    – 进入下一个时钟周期时，转移条件和转移目标地址
      不能按时提供给IF段取指令
    – 计算转移目标地址要花时间
    – 对于条件转移，转移条件分析要花时间计算
*** 解决方法
**** 冻结/冲刷流水线
**** 预测转移不发生
**** 预测转移发生
**** 转移延迟
***** 可以将转移条件和地址的计算都放在ID级
***** 不过总是有需要等待一个时钟
      在MIPS中，无论转移是否发生，这个周期的指令总是要执行(hardware scheme)
      这个周期被称为延迟转移槽, 编译器可以将合适的代码调度到其中
* 增加内容 -- 流水线处理机制及设计
** 流水线性能指标
*** 流水线吞吐率
     - $T_p = \frac{n}{T_k}$
     - $n$ 为任务数量, $T_k$ 是处理完 $n$ 个任务所用的时间
     - 意义应该是: 流水线平均执行完一个指令所需要的时间的倒数(所以是速率?)
     - 如果每一个流水段的运行时间为$\Delta t$, 则流水线的最大吞吐率为$\frac{1}{\Delta t}$.
*** 流水线加速比
    - $S = \frac{T_s}{T_k}$
    - 其中, $T_s$ 表示顺序方式执行所用的时间, $T_k$ 表示以流水线方式执行所用的时间
*** 流水线效率
    - 流水线效率是指: 流水线中的功能部件的利用率, 
      其值为流水线功能部件的实际使用时间与整个运行时间之比
    - $E = \frac{n}{k + n - 1}$
** 流水线处理机的控制
*** 有限状态机硬布线
*** 微程序
** 流水线转移控制指令
   - NOP
   - 延迟指令: 转移指令的下一条指令
** 结构相关的解决方法
*** 增加硬件资源
    分开指令cache和数据cache
*** 功能部件完全流水
*** 停顿
** 数据相关的解决办法
*** WB提前半周期
*** 检测数据冒险
    - 基本条件: $(ID_{rs1} == EXE_{rd}) + (ID_{rs1} == MEM_{rd}) + (ID_{rs2} == EXE_{rd}) + (ID_{rs2} == MEM_{rd})$
    - 有些指令使用了立即数, 某一个操作数不参与判断数据冒险
    - EXE的wreg信号用于判断rd是不是store中的rd
    - ID记得指令不能是转移指令, 转移指令不需要判数据相关
    [[file:pic/%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A3%80%E6%B5%8B.png]]
*** 插NOP
*** 硬件停顿
*** Forwarding
** 转移相关的解决办法
*** 暂停流水线
*** 假定转移不发生
*** 延迟转移
    - 硬件支持
    - 编译器支持
** 异常事件处理
   - 类似中断, 异常发生时, 保存当前地址, 然后调用中断服务程序
*** 精确异常
    - 如果流水线停下来使异常指令之前的指令能正常结束，
      异常指令之后的指令能重新启动，则称该流水线是精确异常。
      – 异常指令之前的所有指令正常完成
      – 异常指令及其后进入流水线的指令没有改变机器的
        状态。
*** 非精确异常
    当不同指令执行需要的时钟周期数有多种时，难以实现精确异常
    - 在某条指令产生异常之前，后面的指令可能已经执行完毕
*** 同一个时钟周期中的多个异常
    - 应该优先处理前面发生的异常, 处理完之后再重新执行指令时, 如果后面的异常发生, 再去处理后面的异常.
*** 多个异常的乱序产生
    - 将每个指令执行过程中产生的异常保存流水线寄存器中(累计), 
      然后在指令即将离开流水线时统一处理. (注意还是要先响应前面流水段中出现的异常)
*** 指令集引起的复杂问题(整型指令) ——定义提交
    - 当一条指令保证能够正常执行完成时，则称它为已提交
    – 在MIPS整数流水线中, 所有指令在MEM阶段结束时，都是已提交。即，没有指令在MEM级之前更新状态。
    – 这意味着指令在已提交之前废除，就不会影响系统的状态。
    – 如果在指令提交之前不更新处理器的状态，则容易实现精确异常处理。
    – 在大多数RISC系统中，每条指令只写一次结果。
** 扩展流水线到多执行周期操作
*** 术语
    - 延迟: 下一条指令能正常使用上条指令的结果而需等待的周期数
    - 初始间隔: 多条指令发射到同一个部件需要间隔的时钟周期数(避免结构冒险)
*** 数据相关的分类
    - RAW
    - WAW
    - WAR
** 精确维护异常处理
*** 方案一: 忽略该问题
    - 提供两种模式, 一种快但不精确, 一种慢但精确(比如限制一个时刻只能有一条指令在流水线上)
*** 方案二: 缓存结果和延迟提交
    - 保证指令完成之前, CPU不改变任何状态 (写寄存器或存储器)
**** 变种1 (历史文件) : 缓存最近已经改写的寄存器的原始值 (可以直接存放每个周期的值)
**** 变种2 (未来文件) : 缓存寄存器的新值, 完成指令时再用新值去更新
*** 方案三: 将指令序列保存下来(可以保存PC), 通过软件来重新完成之前未完成的指令
*** 方案四: 在确认以前完成的指令没有引起异常后，才允许流水线上指令继续
** 为流水线设计指令系统的提示
*** 避免可变长指令和指令执行时间差异过大
*** 避免复杂的寻址方式
*** 避免隐含地设置条件码 (专指处理控制冒险时)
* 指令级并行
** 定义
*** 指令级并行
    几乎所有的处理机都利用流水线来使指令重叠并行执行, 以达到提高性能的目的。
    这种指令之间存在的潜在并行性称为指令级并行。(ILP:Instruction-Level Parallelism)
*** 静态调度
    在编译阶段静态的发现指令级并行，再重新排序和优 化指令序列
*** 动态调度
    在硬件执行指令时，动态的发现指令级的并行，允许指令乱序执行
*** 流水线CPI= 理想CPI+结构相关停顿+数据相关停顿+控制相关停顿
*** 基本程序块
*** 循环级并行
** 循环展开调度的基本方法
   – 指令调度技术
   – 循环展开(loop unrolling)技术 
   – 换名技术
** 相关性分析
*** 程序中的相关
    - 数据相关
    - 名相关
    - 控制相关
*** 数据相关(先写后读相关)
    - 寄存器
    - 存储器(检测要更难)
*** 名相关
    - 名: 指令使用的寄存器或存储单元被称为名
    - 名相关: 两条指令使用相同的名, 但是它们之间没有数据流
**** 反相关
     反相关:指令i先执行，指令j写的名是指令i读的名。
     反相关指令间的顺序是必须保证的。反相关可能引起读后写冒险。
**** 输出相关
     指令j和指令i写相同的名。
     输出相关指令的执行顺序是不能颠倒的。
     输出相关可能引起写后写冒险(WRW)
**** 在调度改变指令顺序时, 必须消除名相关 (寄存器换名)
     对寄存器操作数进行换名称为寄存器换名。
     这个过程可以用编译器静态完成，也可以用硬件动态完成
*** 控制相关
    [[file:pic/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E4%B8%BE%E4%BE%8B.png]]
    循环展开之后, 可以考虑删掉依稀的循环控制指令, 这样可以减少控制相关
    [[file:pic/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%99%90%E5%88%B6.png]]
    所以循环展开实际上是在消除控制相关?
** 指令动态调度
*** 计分牌
**** 执行过程
     - 流出(IS): 判断结构相关和WAW
     - 读操作数(RO): 判断数据相关(RAW)
     - 执行(EX)
     - 写结果(WR): 判断WAR
     - *没有前推
     - 注意必须按照指令顺序流出
**** 计分牌数据结构
***** 指令状态表
      记录各个指令执行过了哪些流水段
***** 功能部件状态表
      - Busy: 当前功能部件是否在工作
      - Op: 当前功能部件执行的操作
      - Fi: 目的寄存器编号
      - Fj, Fk: 源寄存器编号
      - Qj, Qk: 有数据相关时, 记录向Fj, Fk中写结果的功能部件
      - Rj, Rk: 表示Fj, Fk是否已经就绪(IS), 或者是否已经被使用过(RO, EX, WR).
***** 结果寄存器状态表
      - 记录将要写入当前寄存器的功能部件的编号
**** 计分牌算法
***** 约定
      - FU: 指令使用的功能部件的名字
      - D: 指令的结果寄存器的名字
      - S1, S2: 源操作数寄存器
      - OP: 进行的操作
      - Fj(FU): 功能部件表中FU的Fj域
      - result(D): 结果寄存器中状态表D的位置上的内容
**** 记分牌的性能受限于以下几个方面
     [[file:pic/%E8%AE%A1%E5%88%86%E7%89%8C%E6%80%A7%E8%83%BD%E5%8F%97%E9%99%90%E6%96%B9%E9%9D%A2.png]]
**** 评价
     对于数据相关, 名相关, 通过延迟指令执行的方式实现
     - Tomasulo算法可以动态消除名相关
*** Tomasulo算法
**** 机构
     - 5个保留站
     - 6个取缓冲
     - 3个存缓冲
**** 与计分牌不同
     - 保留站/缓冲 控制指令执行 (计分牌集中控制)
     - 前推 (计分牌没有前推)
**** 工作阶段
     - 流出(IS), 检查结构相关, 并通过保留站号替换寄存器号(寄存器换名)
     - 执行(EX), 检测RAW
     - 写结果(WR)
**** 数据结构
***** 保留站
      - Busy
      - OP
      - Vj, Vk: 两个就绪源操作数的值
      - Qj, Qk: 产生源操作数的保留站号
***** 取缓冲
      - Busy
      - A: load的地址, 初始保存偏移量, 计算地址结束后保存有效地址
      - Vj: 地址分量寄存器值
      - Qj: 来源保留站号
***** 存缓冲
      - Busy
      - Vk: 要存入存储器的数据
      - Qk: 数据来源
      - A: 地址偏移量/地址
      - Vj: 地址分量
      - Qj: 来源保留站号
***** 寄存器状态表
      - 寄存器号
      - 保留站号
***** 指令状态表(抽象)
      - 每个保留站中都存有当前指令的状态
**** 优点(相对于计分牌)
     - 寄存器换名消除了名相关的阻塞
     - 分布式数据相关检测
     - CDB总线相当于直通数据通路
** 转移预测技术
   - 静态预测, 预测方向固定不变, 准确率不够高
*** 动态转移预测
    通过过去转移的历史来预测下一次转移的方向
*** 转移预测缓存(BPB, branch prediction buffer) (转移历史表)
   - 转移预测缓存可以和指令直接存在一起
   - 根据这个表的内容判断是否转移n
   - 根据实际的转移情况来修改/不修改预测位
*** 转移目标缓冲(BTB, Branch Target Buffer)
   - 当命中缓冲区时可以从缓冲区直接得到目标地址
**** 数据结构
     表中存放转移成功的转移指令的地址, 表中的内容是:
     - 预测转移目标的地址
     - 可选字段: 转移预测位
**** 另外一种形式
     - 可以将目标地址改为目标地址处的指令
*** 基于硬件的前瞻执行 (猜测执行, 推测执行)
    将 Tomasulo 和动态预测技术相结合
**** 思想
     - 动态分之预测来选择之后要执行的语句
     - 在控制相关消除之前, 指令前瞻执行
     - 跨基本块进行动态调度
**** 如何实现前瞻执行
     - 前瞻执行的结果不是实际结果, 需要存在ROB (ReOrder Buffer)
     - 任何使用了ROB中结果的指令, 也被是为前瞻执行
     - 前瞻执行的指令最终会处于确认阶段, 这个时候可以写寄存器或存储器 (可以将ROB和存缓冲统一起来)
**** 执行阶段
     - 流出, 有空的保留站和ROB项, 操作数保存值/ROB号
     - 执行, 操作数都有效之后, 即可开始执行
     - 写结果
     - 确认, 如果转移错误, 需要取消转移指令之后的ROB项, 病虫分之的正确入口重新开始执行
**** 数据结构
***** ROB项
      - 指令类型: (1) 转移 (2) 存操作 (3) 其他
      - 目的地址: (1) 寄存器 (2) 存储器
      - 值: 保存要写到结果/存储器单元的值 (前瞻执行的结果)
      - 状态: 该指令的状态
*** P II
**** 静态分支预测
     - 分支指令第一次执行, 使用静态分支指令
**** 动态分支预测
     - 256个预测项, 除了目标地址外, 还有转移预测缓存
** 多发射(多流出)技术
   - 多发射处理机: 在一个时钟周期可以同时发射多条指令的处理机
*** 超标量技术
    - 标量处理机: 处理机每条指令的处理对象是一个或一对(如加法)表量.
    - 超标量处理机: 处理机内部存在两条以上的指令流水线
    - 问题: 需要同时调度更加多的不想管指令 -> (1) 静态调度 (2) Tomasulo
**** 多流水线调度
     - 顺序发射, 顺序完成
     - 顺序发射, 乱序完成
     - 乱序发射, 乱序完成
**** (操作部件的) 资源冲突
     - 部件内有流水线
     - 部件内没流水线
**** 典型处理机结构
***** DEC公司Alpha21064
*** 超长指令字技术
    [[file:pic/%E8%B6%85%E9%95%BF%E6%8C%87%E4%BB%A4%E5%AD%97.png]]
** Intel Pentium 4
* 存储器层次结构设计
** Cache组织的基本单位
   Cache:按块(block)进行管理的。
   Cache和主存均被分割成大小相同的块。
   对Cache和主存的访问是以块为基本单位。
** Cache设计需要回答的四个最基本的问题
*** 映像规则
**** 直接映像
**** 全相连
**** 组相连
*** 块识别
**** 数据格式
     $\underbrace{\mbox{Tag}|\mbox{Index}}_{\mbox{Block Address}}|\mbox{Offset}$
     有些时候可能还有标志位, 表示该项是否可用
*** 块替换
**** 随即替换
**** LRU
**** FIFO
*** 写策略
**** 写回
**** 写直达
***** 写停顿
      采用写直达, CPU必须等待写操作完成
***** 写缓冲
      搞一个小缓冲, 存放的古代写入主存的几个值
**** 写缺失
     要写cache时, 要写的块不在cache
***** 写分配
      将要写的东西调入cache
***** 不安写分配
      直接将东西写回主存
*** 分离cache与一体cache
**** 一体
     所有访问都对单个cache进行
**** 分离指令和数据
     指令和数据存在不同的cache中
** Cache性能
*** 术语
    - 缺失率 = 缺失次数 / 访问总次数
    - 多个cache的平均缺失率: 每个cache访问次数比例的加权平均
    - 缺失代价 = cache访问缺失时, 访问下一级存储器所花费的时间, 通常用时钟周期数表示
    - CPU执行时间 = (CPU时钟周期数 + 存储器停顿周期数) * 时钟周期
      - 存储器停顿周期数 = 指令数 * 每条指令访存次数 * 缺失率 * 缺失代价
    - 平均存储器访问时间 = 总访存时间 / 存储器访问总次数
** Cache优化
*** 减少缺失率
**** 增大块容量
     减少强制缺失率, 增大冲突缺失
**** 增大cache容量
**** 更大的相连度
***** 2:1经验法则
      一个容量为N直接映像cache与容量为N/2的2-路组相联cache具有相同的缺失率
    从实用角度，8-路组相联cache与相同容量全相联cache有效减少冲突缺失的效果几乎相当
**** 编译器优化
     - 预测转移发生
     - 合并数组
     - 循环交换
     - 循环融合
     - 分块
*** 减少缺失代价 
**** 多级cache
**** 关键字优先和提前重启动
     不等获取整个块就重起CPU
***** 关键字优先
      首先从存储器请求缺失的字并尽可能快地送到CPU；
      让CPU继续执行同时填放块中的其余字。
      也称为wrapped fetch和requested word first
***** 提前重启动
      以正常顺序取块，只要块中所请求的字到达，就送到CPU，让CPU继续执行。
**** 读缺失优先于写
**** 合并写缓冲
**** 牺牲缓存
*** 利用并行减少Cache缺失代价或缺失率
**** 非阻塞cache
**** 硬件预取
**** 编译控制预取
*** 减少cache命中时间
**** 小和简单的cache
**** 在cache索引时避免地址转换
***** 虚拟索引, 物理标识
***** 虚拟cache, 虚拟标识
**** 流水线化cache访问
**** 路预测
**** 踪迹cache
** 存储器层次结构
*** 单体多字存储器
*** 交叉存储器
** 主存储器技术
*** 访问时间
    一个读请求开始到读出的字到达所需时间
*** 访存周期时间 
    访问存储器2个请求之间的时间 
