#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup
#+BEGIN_COMMENT
=1= 概论
#+END_COMMENT
* 操作系统的目标与功能
** 定义
   - 控制应用程序执行的程序
   - 应用程序和计算机硬件之间的接口
** 目标
   - 方便 (使用)
   - 有效 (资源)
   - 扩展能力
** 基本功能/提供的服务
   - 程序开发
   - 程序运行
   - I/O
   - 文件 (对存储介质进行抽象)
   - 系统访问 (资源保护/资源竞争)
   - 错误检测和响应
   - 记账
* 操作系统的发展过程
** 串行处理
** 简单批处理系统
** 多道批处理系统
*** 并发 vs 并行
    - 并发: 两个或多个事件在同一事件间隔内发生
    - 并行: 两个或多个事件在同一时刻发生
** 分时系统
   使用了和多道处理系统相似的技术, 但是目标是减少响应时间(一般来自用户).
   一般是为了方便支持多个用户使用同一台计算机.
   通常是: 多路, 独立, 及时, 交互的.
** 实时系统
   目标是使系统能够及时的响应外部事件的请求. 能够在规定时间内开始或完成对该事件的处理.
  
* 操作系统的主要成就
  - 进程
  - 内存管理
  - 信息保护和安全
  - 调度和资源管理
* 操作系统的基本特征
** 并发性
   最重要, 是其他特性的前提.
*** 并发 vs 并行
    - 并发: 两个或多个事件在同一事件间隔内发生
    - 并行: 两个或多个事件在同一时刻发生

** 共享
   系统资源可供多个并发执行的进程共同使用
** 虚拟性
   对物理实体进程抽象
** 异步性(不确定性)
   指程序执行过程中的异步性. 即, 我们不能确定:
   - 何时执行
   - 执行顺序
   - 完成运行所需时间
* 操作系统的体系结构
** 层次化
** 单体内核
** 微内核
** 模块化
   
#+BEGIN_COMMENT
=2= 进程管理
#+END_COMMENT
* 进程定义
  为了控制多道程序能够正确的并发执行, 所以引入进程.
** 典型的定义
   - 一个正在执行的程序
   - 能分配给处理器并由处理器执行的实体
   - {指令, 当前状态, 相关系统资源表征} (活动单元)
** 组成
   - 程序代码
   - 相关数据
   - 进程控制块
     | 项目       |
     | 标识符     |
     | 优先级    |
     | 程序计数器 |
     | 内存指针   |
     | 上下文数据 |
     | IO状态     |
     | 记账信息   |
** 基本特征
   - 动态性 (本质)
     存在生命周期
   - 并发性 (重要)
     可以和其他进程一起向前推进
   - 独立性
     各个进程地址空间相互独立
   - 异步性
* 进程状态
** 进程轨迹(trace)
   列出进程执行的指令序列, 可以描述单个进程的行为, 
   这样的序列称为 =进程轨迹(trace)=.
   给出各个进程的trace的交替序列, 可以描述处理器的行为.
   书上73页.
** 进程状态
*** 三状态模型 {就绪, 执行, 阻塞}
    [[file:pic/3-state.png]]
*** 五状态模型 {执行, 阻塞, 就绪, 新建, 终止}
    [[file:pic/5-state.png]]
    - 新建:
      - 已经有了 {进程标识符(PID), 管理进程所需的表格(PCB)}
      - 还没有 {将程序加载到主存, 将数据加载到主存, 执行资格}
    - 终止:
      - 没有了 {执行资格}
      - 其他还在
**** 阻塞队列
     - {单阻塞, 单就绪} 队列
     - {多阻塞, 单就绪} 队列
*** 考虑挂起进程模型
**** 为什么要挂起
     - 内存资源紧张
     - 希望能够容纳尽量多的进程, 防止所有进程都被阻塞的情况发生.
**** 解决方案 -- 交换技术(Swapping)
     被交换到外存的进程, 状态变为 =挂起=.
     于是{就绪, 阻塞}变为了{就绪, 阻塞, 就绪/挂起, 阻塞/挂起}
     [[file:pic/suspend-state.png]]

* 进程描述
** 进程控制结构
*** 进程的物理存在 -- 进程印像(Process Image)
    - 程序段 + 数据段 + PCB + 栈
*** PCB
**** 作用
     - 进程存在的唯一标志
       PCB 常驻内存 (不会被换出)
**** 内容
     - 进程标识 {PID, 父进程PID, 用户ID}
     - 处理机状态 {通用寄存器, 控制和状态寄存器, 栈指针}
     - 进程控制信息 {调度和状态信息, 数据结构, 进程间通信, 存储管理, 资源所有权和使用情况}
* 内核功能和执行模式
** 内核功能
*** 资源管理功能
    [[file:pic/ziyuan.png]]
*** 支撑功能
    [[file:pic/zhicheng.png]]
** 执行模式 {内核, 用户}
   - 原因: 保护操作系统的数据结构不被破坏
   - 实现: IA-64体系结构处理器中的PSR寄存器中存在指示执行模式的位
* 进程控制
** 内容
  - {创建, 撤销}
  - {阻塞, 唤醒}
  - {挂起, 激活}
  - 切换@{时钟中断, I/O中断, 内存失效, 陷阱(当前指令出问题), 系统调用}
** 实现
    进程控制由原语实现.
*** 原语 (Primitive)
    用于完成一定功能的过程. 
    原子操作, 不允许被中断. 
    
** Unix 进程控制
   [[file:pic/unix-state.png]]
   _注意fork()_: 
   - fork()在子进程中返回0,
   - 在父进程总返回子进程的pid
* 线程
** 提出
   操作系统应该能够分别处理 =资源问题= 和 =调度问题=
*** 区分
   - 进程: 资源分配的基本单位
   - 线程: 调度和分派的基本单位
*** 一些术语
   /多线程(multithreading): 指操作系统在 _单个_ 进程内支持多个并发路径的能力/
   /单线程方法:每个进程中只有一个线程在执行的方法/
*** 例子
    |        | 单线程   | 多线程                     |
    | 单进程 | MS DOS   | Java 运行环境              |
    | 多进程 | 传统Unix | Windows, Solaris, 现代Unix |
** 多线程环境, 用到的资源和保护
   - 容纳进程映像的虚拟地址空间
   - 对{CPU, 其他进程, 文件, I/O}的受保护访问.
** 每个线程的内容
   [[file:pic/threadVSprocess.png]]
   - {state(ready, block ...), context(register ...), stack{user, kernel}}
   - 用于存放局部变量的静态存储空间
   - 与进程内其他线程共享的内存和资源访问
** 线程状态变化的基本操作
   - 派生
   - 阻塞
   - 接触阻塞
   - 结束
** 线程的优点
   - 创建时间小于进程
   - 终止时间小于进程
   - 切换时间小于进程
   - 提高了不同执行程序间通信的效率
** 线程分类
**** 用户级 (ULT: User-Level Thread)
***** 优点
      - 可以运行在任何操作系统上
      - 调度策略因应用程序而不同
      - 线程切换不需要内核模式特权
***** 缺点
      - 一个线程阻塞, 则系统会阻塞这个进程下的所有线程 -> 解决办法 {
          将可能产生阻塞的系统调用转化为一个非阻塞的系统调用:
          用一个(套管)例程来判断资源是否可用, 不可用则阻塞当前线程, 等下次轮到该线程的时候继续判断
        }
      - 不能利用多处理技术 -> 解决办法 {
           将应用写出多进程
        }
**** 内核级 (KLT: Kernel-Level Thread)
***** 优点
      - 内核可以把同一个进程内的多个线程调度到多处理器上
      - 一个线程阻塞, 内核可以调度同一进程内的其他线程
      - 内核例程本身也可以是多线程
***** 缺点
      - 线程切换需要切换到内核模式
**** 混合方法
     - 线程创建在用户空间完成
     - 线程同步由应用程序完成
     - 一个应用程序中的多个线程被映射到一些(小于等于用户线程数)内核线程上


#+BEGIN_COMMENT
=2.1= 进程调度
#+END_COMMENT       
* 进程调度
** 背景
   有多个进程(线程)竞争CPU, 需要选择下一个要运行的进程(线程)
*** 定义
    用来完成这部分工作的算法称为调度算法
** 类型
   [[file:pic/long-mid-short.png]]
*** 长程调度
*** 中程调度
*** 短程调度
** 概念
*** 响应时间
    提交一个请求, 到收到响应之间的时间间隔
*** 周转时间(驻留时间)
    一个进程从提交到完成之间的时间间隔, $T_i$
*** 截止时间
    某任务必须{开始/完成}的最迟时间
*** 系统吞吐量
    单位时间内, 系统完成的进程数 
*** 处理器利用率
    处理器处于忙状态的时间百分比
*** 平均周转时间
    $T = \frac{1}{n}\sum_{i=1}^n T_i$
*** 带权周转时间
    $W_i = \frac{T_i}{T_{si}}$. $T_{si}$ 表示系统为该进程提供服务的时间
*** 平均带权周转时间
    $T = \frac{1}{n}\sum_{i=1}^n W_i$
** 调度规则设计的出发点
*** 分类
    - 用户 -- 系统
      [[file:pic/user-system.png]]
    - 性能相关的划分
      [[file:pic/performance.png]]
*** 通过分类来选择优化的目标函数
    [[file:pic/object-function.png]]
*** 进程的决策模式
    - 抢占
    - 非抢占
*** 调度选择函数
    [[file:pic/selection-function.png]]
*** 一些调度算法
    [[file:pic/dispatch-algo.png]]
    [[file:pic/FB.png]]
**** 注意事项
     - 图中标注的非抢占有两重意义
       1. 决策函数不会导致抢占
       2. I/O繁忙型进程阻塞之后再返回, 也不能抢占(考虑FCFS).
**** 评价中出现的一些定义
     - 有利: 带权周转时间 $W_i$ 比其他进程大
     - 不利: 带权周转时间 $W_i$ 比其他进程小
**** 评价
     - FCFS (先来先服务)
       - {长进程有利, 短进程不利}
       - {CPU型有利, I/O型不利}
     - RR (时间片轮转)
       - {CPU型有利, I/O型不利} -> VRR算法
     - SPN (短进程优先)
       - 长进程饥饿
     - SRT (剩余时间最短优先) <- 在SPN的基础上增加了剥夺机制
       - 长进程饥饿
     - HRRN (响应比高者优先) <- 综合了一下FCFS和SPN
     - FB (反馈法)
       - 长进程饥饿
** 实时系统与实时调度
*** 定义
    [[file:pic/shishidef.png]]
*** 实时任务分类
    [[file:pic/shishifenlei.png]]
*** 实时操作系统特点
    [[file:pic/shishitedian.png]]
    可确定, 可响应, 用户控制, 可靠, 失效弱化
*** 实时进程的抢占方式 
**** 基于时间片的轮转抢占式调度
     [[file:pic/rts1.png]]
**** 基于优先级的非抢占式调度
     [[file:pic/rts2.png]]
**** 基于优先级的抢占点抢占调度
     [[file:pic/rts3.png]]
**** 立即抢占式调度
     [[file:pic/rts4.png]]
*** 实时进程的调度方法分类 
**** 静态表驱动调度法
     - 用于周期性实时任务
     - 按照一些参数制定调度表, 然后按调度表执行调度
     - 调度表不可修改 (后来的进程只能在之前的基础上制定调度表)
**** 静态优先级抢占调度法
     - 多用于非实时多道程序系统
     - 利用一些参数确定优先级
**** 基于动态规划的调度法 (动态调度表)
     - 系统为新到达的任务和老任务重算一张调度表
**** 动态尽力调度法 (也是基于优先级, 但是是动态的)
     - 广泛用于非周期性实时任务调度
     - 总是尽最大努力尽早调度紧迫任务
*** 限期 (deadline) 调度
**** 定义
     [[file:pic/dd-def.png]]
**** 使用什么抢占方式
     - 启动期限明确: 用非抢占方式 (如基于优先级的非抢占式调度)
       完成自身必要部分之后阻塞自己, 使其他进程能够启动
     - 完成期限明确: 用抢占策略
**** 使用什么调度方式
     - 具有 _完成期限_ 的 _周期性_ 实时任务 : EDF算法 (最早截止时间优先调度)
     - 具有 _开始期限_ 的 _非周期性_ 实时任务: 
       - if 预先知道所有任务的开始截止时间: 
         - 允许CPU空闲的EDF调度算法 (最早截止时间调度) <- 可以从全局考虑, 先来的不一定先执行
     - 速率单调调度算法 (Rate Monotonic Scheduling)
       - 任务周期: 任务两次开始时间的差
       - 任务速率: 任务周期的倒数
       - 如何确定优先级: 周期短 -> 优先级高
       - 系统按优先级从高到低调度
**** 实时系统处理能力的限制
     假定系统有 $m$ 个周期性硬实时任务, 任务 $i$ 的处理时间为 $C_i$, 周期为 $P_i$.
     则在单处理机的情况下, 必须满足下面的限制条件:
     \[\sum_{i=1}^m \frac{C_i}{P_i} \leq 1 \]
**** 优先级反转
     一个高优先级的任务, 简洁被一个低优先级的任务所抢先, 使得两个任务的优先级被倒置.
     [[file:pic/%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC.png]]
     [[file:pic/%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png]]

     
#+BEGIN_COMMENT
=2.2= 同步
#+END_COMMENT
* 同步
** 相关术语
   [[file:pic/%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD.png]]
   [[file:pic/%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD(1).png]]
** 进程间的关系
   - 竞争
   - 通过共享合作
   - 通过通信合作
** 互斥的要求 (访问临界区的原则)
   - 空闲让进: 如临界区空闲, 则有进程申请就立即进入
   - 忙则等待: 每次只允许一个进程处于临界区
   - 有限等待: 保证进程在有限的时间内能够进入临界区
   - 让权等待: 进程在临界区不能长时间阻塞等待某事件
** 互斥: 软件方法 
   - 初步设想: 轮换使用临界区 -> 慢
   - 第一次改进: 设置临界区状态标志 -> 不互斥
   - 第二次改进: 预先表明进入临界区的态度 -> 互斥, 但死锁
   - 第三次改进: 预先表明进入临界区的态度+谦让 -> 互斥, 不死锁, 但可能一都在谦让(费时)
   - Dekker: 给一个序号(回合号), 每个进程可以在特定的回合不谦让
   - Peterson: 和Dekker等价, 但是更简洁了
*** 评价
    - 不能解决忙等现象
    - 难实现多个进程互斥
** 互斥: 硬件方法
*** 屏蔽中断
    - 执行效率下降
    - 无法工作在多处理器环境
*** 机器专用指令
    - exchange
    - compare&swap
**** 评价:
     - 优点: {支持多处理机, 简单易证明, 支持多临界区}
     - 缺点: 可能{忙等, 饥饿, 死锁}
** 信号量
*** 实现
    [[file:pic/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0.png]]
*** 常见模型
**** 生产者/消费者
     [[file:pic/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.png]]
**** 读者/写者
     [[file:pic/%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85.png]]
     - 读者优先
       [[file:pic/%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88.png]]
     - 公平优先
       [[file:pic/%E5%85%AC%E5%B9%B3%E4%BC%98%E5%85%88.png]]
     - 写者优先
       [[file:pic/%E5%86%99%E8%80%85%E4%BC%98%E5%85%88.png]]
     - 写者优先改进
       [[file:pic/%E5%86%99%E8%80%85%E4%BC%98%E5%85%88%E6%94%B9%E8%BF%9B.png]]
**** 两种模型比较
     [[file:pic/%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83.png]]
*** 管程
    有自己局部变量(static), 每个时刻只能有一个进程在管程中.
    /感觉管程有点像一个类, 但是保证一次只能一个进程在调接口/
*** 消息传递
**** 实现
     - send 原语
     - receive 原语
**** 三种同步方式
     - 阻塞发送, 阻塞接受
     - 不阻塞发送, 阻塞接受
     - 不阻塞发送, 不阻塞接受
**** 消息寻址方式
     - 直接
     - 间接 (利用一个公共的数据结构 -- 信箱)
       [[file:pic/%E4%BF%A1%E7%AE%B1.png]]
       举例:
       [[file:pic/%E4%BF%A1%E7%AE%B1%E7%94%A8%E6%B3%95%E4%B8%BE%E4%BE%8B.png]]
       
#+BEGIN_COMMENT
=2.3= 死锁
#+END_COMMENT
* 死锁
** 定义
   - 一组相互竞争系统资源或进行通信的进程间的永久阻塞
   - 当一组进程中的每个进程都在等待某事件, 而只有同组进程中阻塞的其他进程能够促发该事件时, 死锁发生
** 资源分类
   - 可重用资源: 一次仅供一个进程安全使用且不因使用而耗尽的资源 
   - 可消耗资源: 可消耗资源是指可被创建（生产）和销毁（消耗）的资源

   
   
** 死锁的条件
   [[file:pic/%E6%AD%BB%E9%94%81%E7%9A%84%E6%9D%A1%E4%BB%B6.png]]
** 死锁的解决
   [[file:pic/%E6%AD%BB%E9%94%81%E8%A7%A3%E5%86%B3.png]]
*** 死锁预防
    - 防止占有且等待: 一次性请求所有资源
    - 防止不可抢占: 申请资源如被拒绝, 则释放之前占有的资源
    - 防止循环等待: 定义一个资源请求顺序
*** 死锁避免
    [[file:pic/%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D.png]]
    优缺点:
    [[file:pic/%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D%E4%BC%98%E7%BC%BA%E7%82%B9.png]]
*** 死锁检测与解除
    [[file:pic/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B.png]]
    [[file:pic/%E6%AD%BB%E9%94%81%E8%A7%A3%E9%99%A4.png]]
*** 哲学家就餐问题
